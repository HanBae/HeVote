# Detailed Features
## 이더리움 지갑 없이 ÐApp 사용 가능
HeVote에는 특별한 정책을 가지고 있습니다.
HeVote의 일반 사용자는 [Metamask](https://metamask.io/), [Mist](https://github.com/ethereum/mist)와 같은 이더리움 지갑을 사용하지 않아도 투표를 할 수 있습니다.
HeVote의 서버와 이더리움 노드에서 대신 사용자의 이더리움 계정을 생성해주고, 이 계정은 현재 식별자의 역할으로서만 이용하고 있습니다.
하나의 선거에서 투표를 하거나 스마트 컨트렉트의 정보를 바꿀 때의 수수료(gas) 비용은 **선거를 개설한 사용자(선거개설자)**가 전부 부담합니다.
이러한 정책을 세운 이유는 다음과 같습니다.

- 이더리움을 하나도 모르는 사람도 쉽게 투표를 할 수 있기 위해
- 선거개설자의 책임감을 더욱 높이기 위해

이 정책을 시행하면, 선거에 참여하고자 하는 사용자는 이더리움에 대한 부담감과 이질감을 줄일 수 있습니다.
하지만 선거를 개설한 사용자의 부담이 커지기 때문에, ÐApp 서버 관리자는 이더리움 수수료 비용을 예상하여 선거개설자에게 전달해 주어야합니다.


## 동형암호를 통한 비밀 선거 보장
**정확하게 비밀선거를 보장하는지의 검증은 아직 이루어지지 않았습니다.**

HeVote는 [HElib](https://github.com/shaih/HElib)을 이용하여 비밀선거를 보장하고자 하는 목표를 가지고 있습니다.
동형암호의 공개키와 비밀키는 하나의 선거 당 하나씩 분배를 합니다.
공개키와 비밀키의 쓰임새는 다음 그림과 같습니다.

![tally-helib](https://github.com/HanBae/HeVote/blob/master/docs/images/tally-helib.png)

공개키로 투표용지(사용자가 투표한 내역)을 암호화하고, 비밀키로 투표 용지들을 더한 결과 암호문을 복호화합니다.
각 투표용지는 [NTL](http://www.shoup.net/ntl/)의 다항식 벡터로 이루어져 있습니다.
공개키로 투표용지를 암호화하면, CypherText(Ctxt) 객체(암호문)으로 변환됩니다.
공개키는 [IPFS](https://ipfs.io)의 블록체인에 저장하고, 비밀키는 ÐApp 서버 관리자가 관리하도록 하였습니다.

 
## 동형암호 공개키와 암호문을 IPFS에 반영구 저장
비밀키는 위에서 설명한대로 ÐApp 서버에 저장합니다.
IPFS를 사용한 이유는 다음 두가지입니다.

- 후보 리스트를 암호화하여 보낼 때, 간편화하기 위해
- 컨트렉트 수수료 비용을 최소화하기 위해

HeVote의 기본값으로, 자체 IPFS 노드를 운용하는 것이 아니라 [INFURA](https://infura.io)의 IPFS 노드를 사용하고 있습니다.

## 누구나 투표할 수 있는 선거
HeVote의 선거는 모든 유권자가 투표할 수 있는 선거입니다.
투표할 수 있는 사람(유권자)들을 제한을 두는 기능을 차후 추가 예정 중입니다.


## 하나의 선거 당 하나의 스마트 컨트렉트
하나의 선거는 하나의 스마트 컨트렉트 계정을 가지며,
이 스마트 컨트렉트 계정의 스토리지(storage)에 코드와 선거의 정보를 저장합니다.
선거의 정보는 해당 컨트렉트의 필드 변수에 저장이 되며, 선거의 이름, 설명, 상태, 후보 목록 등의
정보를 담고 있습니다.

스마트 컨트렉트가 어떻게 구성되어있는지를 설명드리자면,
선거(Election) 스마트 컨트렉트의 상속구조는 다음과 같습니다.

![election-contract](https://github.com/HanBae/HeVote/blob/master/docs/images/election-contract.png)

우선, `ElectionFactory` 컨트렉트는 ÐApp 서버 관리자만이 가지고 있는 하나의 클래스입니다.
이것은 흔히 OOP에서 알고 있는 factory pattern을 사용한 것으로,
ÐApp 서버 관리자는 이 컨트렉트의 메소드를 호출하여 `Eleciton` 컨트렉트들을 관리합니다.

`Election` 컨트렉트는 `CandidateList` 컨트렉트와 `VoterList` 컨트렉트를 상속받고 있습니다.
이름대로 `CandidateList` 컨트렉트는 후보자의 리스트를 저장하고 후보자에 관련된 메소드를 가지고 있으며,
`VoterList` 컨트렉트는 향후 유권자 한정 선거에서 사용할 유권자 리스트와 유권자의 상태를 저장하는 컨트렉트입니다.

`ElectionFactory`와 `Election` 컨트렉트는 둘 다 `Ownable` 컨트렉트를 상속받고 있습니다.
`Ownable` 컨트렉트는 해당 컨트렉트 계정을 만든 주인의 이더리움 계정 주소를 저장하는 컨트렉트입니다.
추가로, `SafeMath` 컨트렉트는 사칙연산에 대해 정확한 연산을 도와주는 라이브러리로써,
초기 개발(동형암호를 쓰지 않았을 때)에서 사용하던 라이브러리입니다.

## 쉽고 빠른 투표
사용자 입장에서 투표의 과정은 간단합니다.

1. 사이트에 회원가입을 하고 로그인을 합니다.
2. 선거 목록에서 원하는 선거를 선택하여 투표에 참여합니다.
3. 원하는 후보자를 눌러 투표합니다.

## 로그인 / 회원가입
로그인과 회원가입 시의 비밀번호는 해쉬 처리를 하여 안전하게 보호되며,
회원가입 시에 ÐApp 서버와 연결된 이더리움 노드에서 이더리움 계정을 생성합니다.
차후 이더리움 계정이 있는 경우의 개발을 진행할 예정입니다.

## 예정
- 편리한 선거 관리: 관리자 페이지를 개발 중입니다.
- 유권자 한정 선거: 차후 추가 예정입니다.
